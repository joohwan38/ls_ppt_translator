<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>파워포인트 문서 번역기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>파워포인트 문서 번역기</h1>
        
        <div id="dropArea" class="drop-area">
            <p>파워포인트 파일을 여기에 드래그하여 놓거나</p>
            <button id="fileButton" class="file-button">파일 선택하기</button>
            <input type="file" id="fileInput" accept=".pptx" style="display: none;">
        </div>
        
        <div class="info-container">
            <div id="fileInfo" class="file-info">
                <p id="fileName">파일 이름: </p>
                <p id="slideCount">슬라이드 수: </p>
                <p id="textCount">텍스트 요소 수: </p>
            </div>
            
            <div id="stats" class="stats">
                <p>번역 통계: 
                    <span id="totalTexts">0</span>개 항목 중 
                    <span id="processedTexts">0</span>개 처리 
                    (캐시: <span id="cacheHits">0</span>, API: <span id="apiCalls">0</span>)
                </p>
            </div>
        </div>
        
        <div id="errorInfo" class="error-info">
            <!-- <p><strong>Ollama 서버 연결 오류</strong></p>
            <p id="errorDetail">현재 상태: 연결 실패</p>
            <p>해결 방법:</p>
            <ol>
                <li>Ollama가 설치되어 있는지 확인하세요.</li>
                <li>터미널/명령 프롬프트에서 Ollama 를 입력하여 실행 중인지 확인하세요.</li>
                <li>앱을 재시작하여 다시 시도해보세요.</li>
            </ol>
            <button id="retryButton" class="file-button">다시 연결 시도</button> -->
        </div>
        
        <div class="controls">
            <div class="language-selector-row">
                <div class="language-section">
                    <label for="sourceLanguage">원본 언어:</label>
                    <select id="sourceLanguage">
                        <option value="auto">자동 감지</option>
                        <option value="en">영어</option>
                        <option value="ko">한국어</option>
                        <option value="ja">일본어</option>
                        <option value="zh">중국어</option>
                        <option value="zh-TW">대만어(중국어 번체)</option>
                        <option value="th">태국어</option>
                        <option value="fr">프랑스어</option>
                        <option value="de">독일어</option>
                        <option value="es">스페인어</option>
                    </select>
                </div>
                
                <button id="swapLanguages" class="swap-button" title="언어 교환">
                    <span>⇄</span>
                </button>
                
                <div class="language-section">
                    <label for="targetLanguage">번역 언어:</label>
                    <select id="targetLanguage">
                        <option value="ko">한국어</option>
                        <option value="en">영어</option>
                        <option value="ja">일본어</option>
                        <option value="zh">중국어</option>
                        <option value="zh-TW">대만어(중국어 번체)</option>
                        <option value="th">태국어</option>
                        <option value="fr">프랑스어</option>
                        <option value="de">독일어</option>
                        <option value="es">스페인어</option>
                    </select>
                </div>
            </div>
            <div class="row">
                <label for="modelSelect">Ollama 모델:</label>
                <select id="modelSelect">
                    <option value="">모델 로딩 중...</option>
                </select>
            </div>
            <div class="row">
                <label for="ollamaUrl">Ollama URL:</label>
                <input type="text" id="ollamaUrl" placeholder="http://localhost:11434" value="http://localhost:11434">
            </div>
            <div class="button-group">
                <button id="translateButton" class="half-width" disabled>번역 시작</button>
                <button id="cancelButton" class="half-width" disabled>번역 중지</button>
            </div>
        </div>
        
        <div id="progressContainer" class="progress-container">
            <div class="progress-bar">
                <div id="progressBar" class="progress"></div>
            </div>
            <p id="status" class="status">준비 중...</p>
        </div>
        
        <div id="result" class="result">
            <p>번역이 완료되었습니다!</p>
            <div class="button-group">
                <button id="downloadButton" class="half-width">번역된 파일 다운로드</button>
                <button id="openFileButton" class="half-width">저장된 파일 열기</button>
            </div>
        </div>
    </div>

    <script>
        // 변수 초기화
        let uploadedFile = null, zipInstance = null, slideFilesData = [], translationCache = {}, ollamaInstalled = false;
        let translationStats = {totalTexts: 0, filteredTexts: 0, processedTexts: 0, cacheHits: 0, apiCalls: 0};
        let isTranslating = false;
        let shouldCancel = false;
        let activeAbortController = null;
        let lastSavedFilePath = '';

        // DOM 요소 참조 - 간소화 버전
        const elements = {
            dropArea: document.getElementById('dropArea'),
            fileInput: document.getElementById('fileInput'),
            fileButton: document.getElementById('fileButton'),
            fileInfo: document.getElementById('fileInfo'),
            fileName: document.getElementById('fileName'),
            slideCount: document.getElementById('slideCount'),
            textCount: document.getElementById('textCount'),
            errorInfo: document.getElementById('errorInfo'),
            translateButton: document.getElementById('translateButton'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            status: document.getElementById('status'),
            result: document.getElementById('result'),
            downloadButton: document.getElementById('downloadButton'),
            sourceLanguage: document.getElementById('sourceLanguage'),
            targetLanguage: document.getElementById('targetLanguage'),
            modelSelect: document.getElementById('modelSelect'),
            ollamaUrl: document.getElementById('ollamaUrl'),
            retryButton: document.getElementById('retryButton'),
            errorDetail: document.getElementById('errorDetail'),
            stats: document.getElementById('stats'),
            totalTextsEl: document.getElementById('totalTexts'),
            filteredTextsEl: document.getElementById('filteredTexts'),
            processedTextsEl: document.getElementById('processedTexts'),
            cacheHitsEl: document.getElementById('cacheHits'),
            apiCallsEl: document.getElementById('apiCalls'),
            cancelButton: document.getElementById('cancelButton'),
            openFileButton: document.getElementById('openFileButton')
        };

        // 유틸리티 함수
        const utils = {
            updateStats() {
                elements.totalTextsEl.textContent = translationStats.totalTexts;
                elements.processedTextsEl.textContent = translationStats.processedTexts;
                elements.cacheHitsEl.textContent = translationStats.cacheHits;
                elements.apiCallsEl.textContent = translationStats.apiCalls;
            },
            
            updateProgress(percent) {
                elements.progressBar.style.width = `${percent}%`;
            }
        };

        // 이벤트 리스너 설정
        window.addEventListener('load', () => {
            checkOllamaStatus();
            elements.cancelButton.disabled = true;
            elements.openFileButton.disabled = true;
        });
        
        elements.dropArea.addEventListener('dragover', e => {
            e.preventDefault();
            elements.dropArea.classList.add('active');
        });

        elements.dropArea.addEventListener('dragleave', () => elements.dropArea.classList.remove('active'));

        elements.dropArea.addEventListener('drop', e => {
            e.preventDefault();
            elements.dropArea.classList.remove('active');
            if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });

        elements.fileButton.addEventListener('click', () => elements.fileInput.click());
        elements.fileInput.addEventListener('change', e => {
            if (e.target.files.length) handleFile(e.target.files[0]);
        });

        elements.translateButton.addEventListener('click', startTranslation);
        elements.downloadButton.addEventListener('click', downloadTranslatedFile);
        elements.retryButton.addEventListener('click', checkOllamaStatus);
        elements.ollamaUrl.addEventListener('change', checkOllamaStatus);
        elements.cancelButton.addEventListener('click', cancelTranslation);
        elements.openFileButton.addEventListener('click', openSavedFile);

        // 언어 교환 버튼 이벤트 리스너 추가
        document.getElementById('swapLanguages').addEventListener('click', () => {
            const sourceSelect = document.getElementById('sourceLanguage');
            const targetSelect = document.getElementById('targetLanguage');
            
            // 현재 선택된 값 저장
            const sourceValue = sourceSelect.value;
            const targetValue = targetSelect.value;
            
            // 자동 감지가 선택되어 있으면 교환하지 않음
            if (sourceValue === 'auto') {
                alert('원본 언어가 "자동 감지"로 설정되어 있어 교환할 수 없습니다.');
                return;
            }
            
            // 값 교환
            sourceSelect.value = targetValue;
            targetSelect.value = sourceValue;
        });

        // 번역 취소 함수
        function cancelTranslation() {
            if (isTranslating) {
                shouldCancel = true;
                elements.status.textContent = '번역 중지 중...';
                elements.cancelButton.disabled = true;
                
                if (activeAbortController) {
                    activeAbortController.abort();
                }
            }
        }

        // Ollama 상태 체크 함수
        async function checkOllamaStatus() {
            const url = elements.ollamaUrl.value;
            
            // Electron 환경인지 확인
            if (window.electron && window.electron.checkOllamaStatus) {
                try {
                    const ollamaStatus = await window.electron.checkOllamaStatus();
                    
                    if (!ollamaStatus.installed) {
                        showOllamaInstallGuide();
                        return;
                    }
                    
                    if (!ollamaStatus.running && ollamaStatus.autoStartFailed) {
                        showManualStartGuide();
                        return;
                    }
                    
                    // Ollama가 실행 중이면 잠시 대기 후 모델 목록 로드
                    if (ollamaStatus.running) {
                        setTimeout(() => {
                            loadModelList(url);
                        }, 2000);
                        return;
                    }
                } catch (error) {
                    console.error('Ollama 상태 확인 오류:', error);
                    // 오류 발생 시 직접 API 호출 시도
                    loadModelList(url);
                }
            } else {
                // Electron이 아닌 환경이거나 함수가 없는 경우 직접 API 호출
                loadModelList(url);
            }
        }

        // loadModelList 함수도 수정
        async function loadModelList(url) {
            elements.errorInfo.style.display = 'none';
            elements.modelSelect.innerHTML = '<option value="">모델 로딩 중...</option>';
            
            try {
                const response = await fetch(`${url}/api/tags`, {
                    method: 'GET',
                    headers: {'Content-Type': 'application/json'}
                });
                
                if (!response.ok) throw new Error(`서버 응답 오류: ${response.status}`);
                
                const data = await response.json();
                ollamaInstalled = true;
                
                // 모델 목록 갱신
                elements.modelSelect.innerHTML = '';
                
                if (data.models && data.models.length > 0) {
                    data.models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        elements.modelSelect.appendChild(option);
                    });
                    elements.translateButton.disabled = false; // 모델이 있으면 번역 버튼 활성화
                } else {
                    elements.modelSelect.innerHTML = '<option value="">설치된 모델이 없습니다</option>';
                    elements.translateButton.disabled = true;
                }
            } catch (error) {
                console.error('Ollama 서버 연결 오류:', error);
                ollamaInstalled = false;
                
                // 연결 실패 시 상태 표시
                elements.modelSelect.innerHTML = '<option value="">Ollama 서버에 연결할 수 없습니다</option>';
                elements.translateButton.disabled = true;
                
                // 오류 정보 표시 (설치되지 않았거나 실행되지 않음)
                elements.errorInfo.innerHTML = `
                    <p><strong>Ollama 서버 연결 오류</strong></p>
                    <p>현재 상태: ${error.message}</p>
                    <p>해결 방법:</p>
                    <ol>
                        <li>Ollama가 설치되어 있는지 확인하세요.</li>
                        <li>터미널에서 <code>ollama serve</code> 명령어로 서버를 실행하세요.</li>
                        <li>서버가 실행 중이라면 'http://localhost:11434'가 올바른 주소인지 확인하세요.</li>
                    </ol>
                    <button id="retryButton" class="file-button">다시 연결 시도</button>
                `;
                elements.errorInfo.style.display = 'block';
                
                // 재시도 버튼 이벤트
                document.getElementById('retryButton')?.addEventListener('click', checkOllamaStatus);
            }
        }
        // Ollama 설치 안내 표시
        function showOllamaInstallGuide() {
            elements.errorInfo.innerHTML = `
                <p><strong>Ollama가 설치되지 않았습니다</strong></p>
                <p>파워포인트 번역기를 사용하려면 Ollama를 먼저 설치해야 합니다.</p>
                <p><a href="https://ollama.ai/download" target="_blank" style="color: #2196F3; font-weight: bold;">
                    Ollama 다운로드 페이지에서 설치하기
                </a></p>
                <p>설치 후 앱을 재시작해주세요.</p>
            `;
            elements.errorInfo.style.display = 'block';
            elements.translateButton.disabled = true;
        }

        // 수동 실행 안내 표시
        function showManualStartGuide() {
            elements.errorInfo.innerHTML = `
                <p><strong>Ollama 서버 실행이 필요합니다</strong></p>
                <p>Ollama가 설치되어 있지만 실행되지 않았습니다.</p>
                <p>아래 버튼을 클릭하여 수동으로 실행하거나:</p>
                <ol>
                    <li>터미널(맥) 또는 명령 프롬프트(윈도우)를 엽니다</li>
                    <li><code>ollama serve</code> 명령어를 입력합니다</li>
                    <li>서버가 시작되면 아래 '다시 연결 시도' 버튼을 클릭합니다</li>
                </ol>
                <button id="manualStartButton" class="file-button" style="margin-right: 10px;">
                    Ollama 수동 실행
                </button>
                <button id="retryButton" class="file-button">다시 연결 시도</button>
            `;
            elements.errorInfo.style.display = 'block';
            elements.translateButton.disabled = true;
            
            // 수동 실행 버튼 이벤트 추가
            document.getElementById('manualStartButton')?.addEventListener('click', async () => {
                if (window.electron && window.electron.startOllamaManually) {
                    await window.electron.startOllamaManually();
                    setTimeout(checkOllamaStatus, 5000);
                }
            });
            
            document.getElementById('retryButton')?.addEventListener('click', checkOllamaStatus);
        }

        // 언어 감지 함수
        function detectLanguage(text) {
            if (/[\uAC00-\uD7A3\u3131-\u318E]/.test(text)) return 'ko';
            if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text)) return 'ja';
            if (/[\u0E00-\u0E7F]/.test(text)) return 'th';  // 태국어 감지 추가
            if (/[\u4E00-\u9FFF\u3400-\u4DBF]/.test(text)) {
                // 중국어 번체와 간체 구분은 어렵지만, 일부 특수 문자로 추정 가능
                if (/[\u9E1F\u9CE2\u9ADC\u9B30\u9CCC\u9C67]/.test(text)) {
                    return 'zh-TW';  // 번체에 많이 쓰이는 문자들
                }
                return 'zh';  // 기본값은 간체로
            }
            return 'en';
        }

        // 텍스트 전처리 및 필터링 함수
        // preprocessText 함수를 간소화하여 언어 감지 로직을 완전히 제거
        function preprocessText(text, srcLang, tgtLang) {
            // 빈 텍스트 필터링
            if (!text || text.trim() === '') return null;
            
            // 숫자, 특수문자만 있는 경우는 번역하지 않음 (필요시 유지)
            if (/^[\d\s\p{P}]+$/u.test(text) && !text.includes('(')) return null;
            
            // 언어 감지 로직 제거 - 항상 번역 시도
            return text;
        }

        // 언어별 문자 비율 확인 함수
        function getLanguageChars(text, lang) {
            let pattern;
            switch(lang) {
                case 'ko':
                    pattern = /[\uAC00-\uD7A3\u3131-\u318E]/g;
                    break;
                case 'ja':
                    pattern = /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g;
                    break;
                case 'zh':
                case 'zh-TW':
                    pattern = /[\u4E00-\u9FFF\u3400-\u4DBF]/g;
                    break;
                case 'th':
                    pattern = /[\u0E00-\u0E7F]/g;
                    break;
                default:
                    pattern = /[a-zA-Z]/g; // 영어 등 로마자 기반 언어
            }
            return text.match(pattern) || [];
        }

        // 노드 위치 계산 (정렬용)
        function getNodePosition(node) {
            let position = 0;
            let sibling = node;
            while (sibling.previousSibling) {
                position++;
                sibling = sibling.previousSibling;
            }
            return position;
        }

        // 텍스트 노드 수집기
        function collectTextNodes(container, textRuns) {
            let fullText = '';
            const textNodes = [];
            
            textRuns.sort((a, b) => getNodePosition(a) - getNodePosition(b));
            
            for (const run of textRuns) {
                const tNodes = run.getElementsByTagName('a:t');
                for (let i = 0; i < tNodes.length; i++) {
                    textNodes.push(tNodes[i]);
                    fullText += tNodes[i].textContent;
                }
            }
            
            return { text: fullText.trim(), nodes: textNodes };
        }

        // 파일 처리 함수
        async function handleFile(file) {
            if (!file.name.endsWith('.pptx')) {
                alert('PPTX 파일만 지원합니다.');
                return;
            }

            uploadedFile = file;
            elements.fileName.textContent = `파일 이름: ${file.name}`;
            elements.fileInfo.style.display = 'block';
            elements.slideCount.textContent = '슬라이드 수: 파일 분석 중...';
            elements.textCount.textContent = '텍스트 요소 수: 파일 분석 중...';
            elements.stats.style.display = 'none';
            
            try {
                // 파일 읽기 및 분석
                const arrayBuffer = await file.arrayBuffer();
                zipInstance = await JSZip.loadAsync(arrayBuffer);
                
                // 슬라이드 파일 찾기
                slideFilesData = [];
                const slidePattern = /ppt\/slides\/slide(\d+)\.xml/;
                
                // 슬라이드 파일 수집
                const slideFiles = [];
                
                zipInstance.forEach((path, zipEntry) => {
                    const slideMatch = path.match(slidePattern);
                    if (slideMatch) {
                        slideFiles.push({ 
                            number: parseInt(slideMatch[1], 10),
                            path,
                            zipEntry
                        });
                    }
                });
                
                // 슬라이드 번호 순으로 정렬
                slideFiles.sort((a, b) => a.number - b.number);
                
                // 슬라이드 내용 분석
                let totalTexts = 0;
                
                for (const slideFile of slideFiles) {
                    const xmlContent = await slideFile.zipEntry.async('string');
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
                    
                    const textElements = [];
                    
                    // 텍스트 상자 처리 (p:txBody)
                    const textBodies = xmlDoc.getElementsByTagName('p:txBody');
                    for (const textBody of textBodies) {
                        const paragraphs = textBody.getElementsByTagName('a:p');
                        
                        for (let j = 0; j < paragraphs.length; j++) {
                            const paragraph = paragraphs[j];
                            const textRuns = [
                                ...paragraph.getElementsByTagName('a:r'), 
                                ...paragraph.getElementsByTagName('a:fld')
                            ];
                            
                            const { text, nodes } = collectTextNodes(paragraph, textRuns);
                            
                            if (text) {
                                textElements.push({
                                    text,
                                    nodes,
                                    type: 'paragraph'
                                });
                            }
                        }
                    }
                    
                    // 표 처리 (a:tbl)
                    const tables = xmlDoc.getElementsByTagName('a:tbl');
                    for (const table of tables) {
                        const rows = table.getElementsByTagName('a:tr');
                        for (const row of rows) {
                            const cells = row.getElementsByTagName('a:tc');
                            // 셀 단위로만 처리하는 간단한 방법
                            for (const cell of cells) {
                                const cellTextBody = cell.getElementsByTagName('a:txBody')[0];
                                if (cellTextBody) {
                                    // 셀 전체의 텍스트만 추출
                                    const allText = cellTextBody.textContent.trim();
                                    
                                    if (allText) {
                                        const allNodes = cellTextBody.getElementsByTagName('a:t');
                                        textElements.push({
                                            text: allText,
                                            nodes: [...allNodes],
                                            isTableCell: true,
                                            type: 'cell'
                                        });
                                    }
                                }
                            }
                        }
                    }
                    
                    // 스마트아트 및 기타 특수 요소 처리 (p:graphicFrame > a:graphic)
                    const graphics = xmlDoc.getElementsByTagName('a:graphic');
                    for (const graphic of graphics) {
                        // 다이어그램 텍스트
                        const diagramTexts = graphic.getElementsByTagName('dgm:t');
                        for (const diagramText of diagramTexts) {
                            const runs = [
                                ...diagramText.getElementsByTagName('a:r'), 
                                ...diagramText.getElementsByTagName('a:fld')
                            ];
                            
                            const { text, nodes } = collectTextNodes(diagramText, runs);
                            
                            if (text) {
                                textElements.push({
                                    text,
                                    nodes,
                                    isGraphic: true,
                                    type: 'diagram'
                                });
                            }
                        }
                        
                        // 일반 그래픽 텍스트
                        const textsInGraphic = graphic.getElementsByTagName('a:t');
                        const processedNodes = new Set();
                        
                        // 그래픽 내 문단 단위로 텍스트 병합
                        const paragraphs = graphic.getElementsByTagName('a:p');
                        for (const paragraph of paragraphs) {
                            const runs = [
                                ...paragraph.getElementsByTagName('a:r'),
                                ...paragraph.getElementsByTagName('a:fld')
                            ];
                            
                            let fullText = '';
                            const textNodes = [];
                            
                            for (const run of runs) {
                                const tNodes = run.getElementsByTagName('a:t');
                                for (const tNode of tNodes) {
                                    processedNodes.add(tNode);
                                    textNodes.push(tNode);
                                    fullText += tNode.textContent;
                                }
                            }
                            
                            if (fullText.trim()) {
                                textElements.push({
                                    text: fullText.trim(),
                                    nodes: textNodes,
                                    isGraphic: true,
                                    type: 'graphic-paragraph'
                                });
                            }
                        }
                        
                        // 위 과정에서 처리되지 않은 텍스트 노드 처리
                        for (const textNode of textsInGraphic) {
                            if (!processedNodes.has(textNode)) {
                                const text = textNode.textContent.trim();
                                if (text) {
                                    textElements.push({
                                        text,
                                        nodes: [textNode],
                                        isGraphic: true,
                                        type: 'graphic-text'
                                    });
                                }
                            }
                        }
                    }
                    
                    totalTexts += textElements.length;
                    
                    slideFilesData.push({
                        number: slideFile.number,
                        path: slideFile.path,
                        textElements,
                        xmlDoc,
                        originalXml: xmlContent
                    });
                }
                
                elements.slideCount.textContent = `슬라이드 수: ${slideFilesData.length}`;
                elements.textCount.textContent = `텍스트 요소 수: ${totalTexts}`;
                
                elements.translateButton.disabled = !ollamaInstalled || slideFilesData.length === 0;
                
            } catch (error) {
                console.error('파일 처리 오류:', error);
                alert('파일 처리 중 오류: ' + error.message);
                
                // 오류 발생 시 초기화
                slideFilesData = [];
                elements.translateButton.disabled = true;
                elements.slideCount.textContent = '슬라이드 수: 0';
                elements.textCount.textContent = '텍스트 요소 수: 0';
            }
        }
        
        // 번역 API 호출 함수
        async function translateText(text, srcLang, tgtLang, model, apiUrl) {
            // 언어 코드를 영어 언어명으로 매핑
            const languageNames = {
                'ko': 'Korean',
                'en': 'English',
                'ja': 'Japanese',
                'zh': 'Chinese (Simplified)',
                'zh-TW': 'Chinese (Traditional)',
                'th': 'Thai',
                'fr': 'French',
                'de': 'German',
                'es': 'Spanish'
            };
            
            // 공용 영어 프롬프트 사용
            const targetLangName = languageNames[tgtLang] || tgtLang;
            // 영어 프롬프트 개선
            const prompt = `You are a translator. Your role is to accurately translate the given text into ${targetLangName}. Do not provide any explanations, only the translated result. : "${text}"`;

            console.log(`[번역 요청] 원본(${srcLang} → ${tgtLang}):`, text);
            
            // AbortController 생성
            activeAbortController = new AbortController();
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        prompt: prompt,
                        stream: false
                    }),
                    signal: activeAbortController.signal // Abort 시그널 추가
                });
                
                if (!response.ok) throw new Error(`API 응답 오류: ${response.status}`);
                
                const data = await response.json();

                console.log(`[API 응답]:`, data.response);

                
                // 원본 텍스트에 별표 패턴이 있는지 확인
                const hasAsteriskPattern = /\*[^*]+\*/g.test(text);
                
                // 정제 로직 적용
                let translatedText = data.response.trim()
                    .replace(/^["']|["']$/g, '')  // 따옴표 제거
                    .replace(/^번역: /i, '')      // '번역:' 제거
                    .replace(/^번역 결과: /i, '') // '번역 결과:' 제거
                    .replace(/.*["'](.*)["'].*/g, '$1') // 따옴표 안의 내용만 추출 시도
                    //.replace(/^.*?: /g, '')       // 콜론 뒤의 내용만 추출
                    .trim();

                // 발음 및 설명 패턴 제거 강화
                translatedText = translatedText
                    // 일본어 단어 뒤 괄호 안 로마자 발음
                    .replace(/([一-龯々ぁ-ゔァ-ヴー]+)\s*\(([A-Za-z\s'-]+)\)/g, '$1')
                    // 한자 단어 뒤 괄호 안 로마자 발음 (Dai-kibo 패턴)
                    .replace(/([^\s]+)\s*\(([A-Za-z][a-z'-]+(?:-[a-z]+)*(?:\s+[a-z'-]+)*)\)/g, '$1')
                    // 괄호 안에 한글만 있는 경우
                    .replace(/([^\s]+)\s*\(([가-힣\s]+)\)/g, '$1')
                    // 일본어 한자 + 히라가나 발음 패턴 제거
                    .replace(/([一-龯々]+)\s*\(([ぁ-ゔ]+)\)/g, '$1');

                // 추가: 일본식 괄호 안 로마자 완전 제거 
                // translatedText = translatedText.replace(/\((?:[A-Za-z][a-z'-]+(?:-[a-z]+)*(?:\s+[a-z'-]+)*)\)/g, '');
                
                // AI 설명 패턴 제거
                const explanationPatterns = [
                    /설명:/g,                     // '설명:' 텍스트 제거
                    /혹은 .* 표현/g,              // '혹은 ... 표현' 제거
                    /문맥에 따라/g,               // '문맥에 따라' 제거
                    /의미합니다/g,                // '의미합니다' 제거
                    /뜻으로/g,                    // '뜻으로' 제거
                    /가장 적합한/g,               // '가장 적합한' 제거
                    /직역한/g,                    // '직역한' 제거
                    /표현입니다/g,                // '표현입니다' 제거
                    /[A-Za-z]+ \([A-Za-z ]+\):/g, // 'English (pronunciation):' 패턴 제거
                    /\([^)]*?[가-힣].*?\)/g,      // 한글이 포함된 괄호 내용 제거
                    // 한자 발음 제거 패턴 추가
                    /([一-龯々]+) \(([A-Za-z]+\s*[A-Za-z]*)\)/g, // 한자 (로마자) 패턴
                    /([一-龯々]+)\(([ぁ-ゔァ-ヴー]+)\)/g,        // 한자(히라가나) 패턴
                    /([一-龯々]+)\(([ァ-ヶー]+)\)/g             // 한자(가타카나) 패턴
                ];
                
                // 원본에 별표가 없을 때만 별표 패턴 제거 적용
                if (!hasAsteriskPattern) {
                    explanationPatterns.push(/\*\*.*?\*\*/g);  // **강조** 텍스트 제거
                    explanationPatterns.push(/\*.*?\*/g);      // *강조* 텍스트 제거
                }
                
                // 모든 설명 패턴을 제거
                for (const pattern of explanationPatterns) {
                    translatedText = translatedText.replace(pattern, '');
                }
                
                // 다중 번역 가능성 제거 (AI가 주는 여러 번역 옵션을 제거)
                if (translatedText.includes('혹은') || 
                    translatedText.includes('또는') || 
                    translatedText.includes('일 수도 있고') || 
                    translatedText.includes('혹은 문맥에 따라') ||
                    translatedText.includes('다양한 번역이 가능합니다')) {
                    
                    // 원본에 "또는"이나 "혹은"이 있는 경우 해당 패턴은 보존
                    const originalHasOr = text.includes('또는') || 
                                        text.includes('혹은') || 
                                        text.includes(' or ') || 
                                        text.includes('/');
                    
                    // 원본에 "또는", "혹은" 등이 있는 경우 분리자 목록에서 제외
                    let separators = ['일 수도 있고', '혹은 문맥에 따라'];
                    
                    if (!originalHasOr) {
                        // 원본에 "또는", "혹은" 등이 없는 경우에만 추가
                        separators = [...separators, '혹은', '또는', ', '];
                    }
                    
                    // 분리자로 구분된 첫 번째 번역만 사용
                    for (const separator of separators) {
                        if (translatedText.includes(separator)) {
                            translatedText = translatedText.split(separator)[0].trim();
                        }
                    }
                    
                    // 번역 목록 제거
                    const listPatterns = [
                        /^\* .*/gm,             // * 로 시작하는 목록
                        /^\d+\. .*/gm,          // 숫자로 시작하는 목록 
                        /^- .*/gm               // - 로 시작하는 목록
                    ];
                    
                    for (const pattern of listPatterns) {
                        if (pattern.test(translatedText)) {
                            const lines = translatedText.split('\n');
                            // 목록이 아닌 첫 번째 줄만 사용
                            for (const line of lines) {
                                if (!pattern.test(line) && line.trim()) {
                                    translatedText = line.trim();
                                    break;
                                }
                            }
                        }
                    }
                }
                
                console.log(`[정제 후]:`, translatedText);

                return translatedText;
                
            } catch (error) {
                // 요청이 중단된 경우
                if (error.name === 'AbortError') {
                    throw new Error('번역 요청이 취소되었습니다.');
                }
                throw error; // 다른 오류는 그대로 전달
            }
        }

        // 중복 텍스트 제거 함수는 유지
        function removeDuplicatedText(text, original) {
            // 괄호, 슬래시, 하이픈이 없는 경우에만 중복 제거 적용
            if (original.includes('(') || original.includes('/') || original.includes('-')) {
                return text;
            }
            
            // 전체 문자열 반복 제거
            const repeatedFullTextMatch = text.match(/(.+)(\s+\1)+/i);
            if (repeatedFullTextMatch) {
                return repeatedFullTextMatch[1].trim();
            }
            
            // 부분 문자열 반복 제거
            const detectRepeatedParts = (t) => {
                for (let len = 3; len <= Math.floor(t.length / 2); len++) {
                    for (let i = 0; i <= t.length - len * 2; i++) {
                        const part = t.substring(i, i + len);
                        const nextPart = t.substring(i + len, i + len * 2);
                        if (part === nextPart) {
                            return {
                                repeatedPart: part,
                                startIndex: i,
                                endIndex: i + len * 2
                            };
                        }
                    }
                }
                return null;
            };
            
            let result = text;
            let repeatedPart;
            while ((repeatedPart = detectRepeatedParts(result)) !== null) {
                result = 
                    result.substring(0, repeatedPart.startIndex) + 
                    repeatedPart.repeatedPart + 
                    result.substring(repeatedPart.endIndex);
            }
            
            // 불필요한 숫자 제거 (날짜 뒤에 무의미한 숫자)
            return result.replace(/(\d+[月日])～\d+$/, '');
        }

        // 번역 로직 수정 - translateBatch 함수에서 handleBracketedText 호출 제거
        async function translateBatch(texts, srcLang, tgtLang, model, apiUrl, onProgress) {
            // 중복 제거 및 캐싱 활용
            const uniqueTexts = [...new Set(texts)].filter(text => text !== null);
            const results = {};
            
            let processedCount = 0;
            const totalCount = uniqueTexts.length;
            
            // 통계 초기화
            translationStats.totalTexts = uniqueTexts.length;
            translationStats.processedTexts = 0;
            translationStats.cacheHits = 0;
            translationStats.apiCalls = 0;
            translationStats.filteredTexts = texts.length - uniqueTexts.length;
            utils.updateStats();
            elements.stats.style.display = 'block';
            
            // 병렬 처리를 위한 배치 크기
            const batchSize = 5;
            
            // 번역 작업 처리
            for (let i = 0; i < uniqueTexts.length && !shouldCancel; i += batchSize) {
                // 각 배치 전에 취소 상태 확인
                if (shouldCancel) {
                    console.log("번역 배치 처리 중 취소됨");
                    break;
                }
                
                const batch = uniqueTexts.slice(i, Math.min(i + batchSize, uniqueTexts.length));
                
                // 병렬 처리 방식 변경: 각 Promise를 개별적으로 실행
                for (let j = 0; j < batch.length && !shouldCancel; j++) {
                    const text = batch[j];
                    try {
                        // 취소 상태 확인
                        if (shouldCancel) {
                            console.log("개별 번역 작업 취소됨");
                            break;
                        }
                        
                        // 캐시 확인 및 번역 로직
                        const cacheKey = `${srcLang}|${tgtLang}|${text}`;
                        if (translationCache[cacheKey]) {
                            results[text] = translationCache[cacheKey];
                            translationStats.cacheHits++;
                        } else {
                            // 번역 요청 및 후처리 - 한 번에 처리
                            let translatedText = await translateText(text, srcLang, tgtLang, model, apiUrl);
                            
                            // 취소 확인
                            if (shouldCancel) break;
                            
                            // 중복 번역 제거
                            translatedText = removeDuplicatedText(translatedText, text);
                            
                            // 캐시 저장
                            translationCache[cacheKey] = translatedText;
                            results[text] = translatedText;
                            translationStats.apiCalls++;
                        }
                        
                        processedCount++;
                        translationStats.processedTexts = processedCount;
                        utils.updateStats();
                        onProgress(processedCount / totalCount * 100);
                        
                    } catch (error) {
                        console.error('번역 오류:', error, '텍스트:', text);
                        processedCount++;
                        translationStats.processedTexts = processedCount;
                        utils.updateStats();
                        onProgress(processedCount / totalCount * 100);
                        results[text] = `[번역 오류: ${text}]`;
                    }
                }
            }
            
            return results;
        }

        // 번역 시작 함수
        async function startTranslation() {
            if (!slideFilesData.length || !ollamaInstalled) return;
            
            if (!ollamaInstalled) {
                alert('Ollama 서버에 연결할 수 없습니다. Ollama가 실행 중인지 확인하세요.');
                return;
            }
            
            // 번역 상태 초기화
            isTranslating = true;
            shouldCancel = false;
            elements.translateButton.disabled = true;
            elements.cancelButton.disabled = false;
            elements.progressContainer.style.display = 'block';
            elements.result.style.display = 'none';
            elements.stats.style.display = 'block';
            
            utils.updateProgress(0);
            elements.status.textContent = '번역 준비 중...';
            
            const srcLang = elements.sourceLanguage.value;
            const tgtLang = elements.targetLanguage.value;
            const model = elements.modelSelect.value;
            
            if (!model) {
                alert('번역에 사용할 모델을 선택해주세요.');
                cleanupTranslation();
                return;
            }
            
            const apiUrl = `${elements.ollamaUrl.value}/api/generate`;
            
            try {
                // 모든 텍스트 추출 및 전처리
                elements.status.textContent = '텍스트 분석 중...';
                utils.updateProgress(5);
                
                const allTexts = [];
                const allTextElements = [];
                
                // 모든 슬라이드의 텍스트 수집
                slideFilesData.forEach(slide => {
                    slide.textElements.forEach(element => {
                        const processedText = preprocessText(element.text, srcLang, tgtLang);
                        if (processedText) {
                            allTexts.push(processedText);
                            allTextElements.push(element);
                        }
                    });
                });
                
                // 한 번만 검사: 중지 또는 빈 텍스트 케이스 처리
                if (shouldCancel || allTexts.length === 0) {
                    if (shouldCancel) {
                        elements.status.textContent = '번역이 중지되었습니다.';
                    } else {
                        elements.status.textContent = '번역할 텍스트가 없습니다.';
                        elements.result.style.display = 'block';
                    }
                    cleanupTranslation();
                    return;
                }
                
                // 진행 상황 표시
                elements.status.textContent = `번역 준비 완료: 총 ${allTexts.length}개 텍스트 항목`;
                utils.updateProgress(10);
                
                // 배치 번역 실행
                elements.status.textContent = '번역 중...';
                const translationResults = await translateBatch(
                    allTexts, 
                    srcLang, 
                    tgtLang, 
                    model, 
                    apiUrl, 
                    (progress) => {
                        // 전체 진행률: 10% (준비) + 80% (번역) = 90%
                        utils.updateProgress(10 + progress * 0.8);
                        elements.status.textContent = `번역 중: ${Math.round(progress)}%`;
                        utils.updateStats();
                    }
                );
                
                // 상태 메시지 통합
                elements.status.textContent = shouldCancel ? 
                    '번역이 중지되었습니다. 현재까지 번역된 내용을 적용합니다...' :
                    '번역 결과 적용 중...';
                
                utils.updateProgress(90);
                
                // 언어별 폰트 설정 (이 부분은 그대로 유지)
                const fontsByLanguage = {
                    'ja': 'Noto Sans JP,Noto Sans CJK JP',
                    'zh': 'Noto Sans SC,Noto Sans CJK SC',
                    'zh-TW': 'Noto Sans TC,Noto Sans CJK TC',
                    'ko': 'Noto Sans KR,Noto Sans CJK KR',
                    'th': 'Noto Sans Thai,Noto Sans',
                    'en': 'Noto Sans,Calibri'
                };
                
                const targetFont = fontsByLanguage[tgtLang] || 'Noto Sans';
                
                // 슬라이드 처리
                for (let i = 0; i < slideFilesData.length; i++) {
                    const slide = slideFilesData[i];
                    
                    // 폰트 변경
                    if (tgtLang === 'ja' || tgtLang === 'zh' || tgtLang === 'zh-TW' || tgtLang === 'ko' || tgtLang === 'th') {
                        const eaFonts = slide.xmlDoc.getElementsByTagName('a:ea');
                        for (const font of eaFonts) {
                            font.setAttribute('typeface', targetFont);
                        }
                    } else {
                        const latinFonts = slide.xmlDoc.getElementsByTagName('a:latin');
                        for (const font of latinFonts) {
                            font.setAttribute('typeface', targetFont);
                        }
                    }
                    
                    // 번역된 텍스트 적용
                    for (let j = 0; j < slide.textElements.length; j++) {
                        const element = slide.textElements[j];
                        const processedText = preprocessText(element.text, srcLang, tgtLang);
                        
                        if (processedText && translationResults[processedText]) {
                            // 번역된 텍스트 적용
                            if (element.nodes && element.nodes.length > 0) {
                                element.nodes[0].textContent = translationResults[processedText];
                                
                                // 나머지 노드는 비워두기
                                for (let k = 1; k < element.nodes.length; k++) {
                                    element.nodes[k].textContent = '';
                                }
                            } else if (element.node) {
                                element.node.textContent = translationResults[processedText];
                            }
                        }
                    }
                    
                    // 수정된 XML을 직렬화하여 저장
                    const serializer = new XMLSerializer();
                    slide.modifiedXml = serializer.serializeToString(slide.xmlDoc);
                    
                    // 마지막 슬라이드 처리 후 진행률 업데이트
                    if (i === slideFilesData.length - 1) {
                        utils.updateProgress(100);
                    }
                }
                
                // 최종 상태 메시지 통합
                elements.status.textContent = shouldCancel ? 
                    '번역이 중지되었습니다. 현재까지 번역된 내용이 적용되었습니다.' : 
                    '번역 완료!';
                
                elements.result.style.display = 'block';
                cleanupTranslation();
                
            } catch (error) {
                console.error('번역 오류:', error);
                
                // 오류 처리 통합
                elements.status.textContent = shouldCancel ? 
                    '번역이 중지되었습니다.' : 
                    '번역 중 오류가 발생했습니다: ' + error.message;
                
                // 현재까지 번역된 내용이 있으면 다운로드 가능하게
                if (slideFilesData.some(slide => slide.modifiedXml)) {
                    elements.result.style.display = 'block';
                }
                
                cleanupTranslation();
            }
        }

        // 번역 후 정리 작업을 별도 함수로 분리
        function cleanupTranslation() {
            elements.translateButton.disabled = false;
            isTranslating = false;
            elements.cancelButton.disabled = true;
        }

        // 파일 다운로드 함수 수정
        async function downloadTranslatedFile() {
            if (!slideFilesData.length) return;
            
            elements.status.textContent = '번역된 파일 생성 중...';
            utils.updateProgress(0);
            
            try {
                // 번역된 XML 파일을 원본 ZIP에 적용
                for (let i = 0; i < slideFilesData.length; i++) {
                    const slide = slideFilesData[i];
                    
                    // 수정된 XML을 ZIP에 적용
                    if (slide.modifiedXml) {
                        zipInstance.file(slide.path, slide.modifiedXml);
                    }
                    
                    // 진행 상황 업데이트
                    utils.updateProgress((i + 1) / slideFilesData.length * 100);
                }
                
                // 수정된 ZIP 파일 생성
                const newZipBlob = await zipInstance.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 9 }
                });
                
                // 파일명 설정
                const originalName = uploadedFile.name;
                const baseName = originalName.substring(0, originalName.lastIndexOf('.'));
                const langSuffix = elements.targetLanguage.value;
                const newFileName = `${baseName}_${langSuffix}.pptx`;
                
                // Blob을 ArrayBuffer로 변환
                const arrayBuffer = await newZipBlob.arrayBuffer();
                
                // IPC를 통해 메인 프로세스에 파일 저장 요청
                if (window.electron) {
                    // Electron IPC 통신 사용
                    const result = await window.electron.saveFile({
                        fileName: newFileName,
                        data: arrayBuffer
                    });
                    
                    if (result.success) {
                        lastSavedFilePath = result.filePath;
                        elements.status.textContent = `${result.fileName} 파일이 저장되었습니다.`;
                        elements.openFileButton.disabled = false;
                    } else {
                        elements.status.textContent = result.error || '파일 저장이 취소되었습니다.';
                    }
                } else {
                    // 일반 웹 환경에서는 기존 방식으로 다운로드
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(newZipBlob);
                    downloadLink.download = newFileName;
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    elements.status.textContent = `${newFileName} 파일 다운로드 완료!`;
                }
            } catch (error) {
                console.error('파일 다운로드 오류:', error);
                elements.status.textContent = '파일 생성 중 오류가 발생했습니다: ' + error.message;
                alert('파일 다운로드 오류: ' + error.message);
            }
        }

        // 저장된 파일 열기 함수
        function openSavedFile() {
            if (lastSavedFilePath) {
                if (window.electron) {
                    window.electron.openFile(lastSavedFilePath)
                        .then(result => {
                            if (!result.success) {
                                alert('파일을 열 수 없습니다: ' + result.error);
                            }
                        });
                }
            } else {
                alert('먼저 파일을 저장해주세요.');
            }
        }
    </script>
</body>
</html>